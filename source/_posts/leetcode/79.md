---
title: 79. 单词搜索
categories:
- leetcode算法题
tags:
- Kotlin
- DFS
---
题目链接：https://leetcode-cn.com/problems/word-search/

### Java
``` java
class Solution {
    lateinit var visited: Array<BooleanArray>
    lateinit var board: Array<CharArray>
    private var word: String = ""
    fun exist(board: Array<CharArray>, word: String): Boolean {
        val row = board.size
        val columns = board[0].size
        this.visited = Array(row) { BooleanArray(columns) }
        this.board = board
        this.word = word
        for (i in 0 until row) {
            for (j in 0 until columns) {
                if (board[i][j] == word[0]) {
                    if (dfs(i, j, 0)) return true
                }
            }
        }
        return false
    }

    private fun dfs(
        i: Int,
        j: Int,
        nowIndex: Int
    ): Boolean {
        if (nowIndex == word.length) return true
        if (i < 0 ||
            i >= board.size ||
            j < 0 ||
            j >= board[0].size ||
            visited[i][j] ||
            board[i][j] != word[nowIndex]) return false
        visited[i][j] = true
        val nextPos = nowIndex + 1
        if (dfs(i - 1, j, nextPos) 
            || dfs(i + 1, j, nextPos) 
            || dfs(i, j - 1, nextPos) 
            || dfs(i, j + 1, nextPos)) {
            return true
        }
        visited[i][j] = false
        return false
    }
}
```

### Kotlin
``` kotlin
class Solution {
    fun exist(board: Array<CharArray>, word: String): Boolean {
        val row = board.size
        val columns = board[0].size
        var visited = Array(row) { BooleanArray(columns) }
        for (i in 0 until row) {
            for (j in 0 until columns) {
                if (dfs(board, visited, i, j, word, 0)) return true
            }
        }
        return false
    }

    private fun dfs(
        board: Array<CharArray>,
        visited: Array<BooleanArray>,
        i: Int,
        j: Int,
        word: String,
        k: Int
    ): Boolean {
        if (board[i][j] != word[k]) {
            return false
        } else if (k == word.length - 1) {
            return true
        }
        visited[i][j] = true
        val directions = arrayOf(intArrayOf(0, 1), intArrayOf(0, -1), intArrayOf(1, 0), intArrayOf(-1, 0))
        var result = false
        for (dir in directions) {
            val x = i + dir[0] // 上下行
            val y = j + dir[1] // 左右列
            if (x >= 0 && y >= 0 && x < board.size && y < board[0].size) {
                if (!visited[x][y]) {
                    val flag = dfs(board, visited, x, y, word, k + 1)
                    if (flag) {
                        result = true
                        break
                    }
                }
            }
        }
        visited[i][j] = false
        return result
    }
}

```