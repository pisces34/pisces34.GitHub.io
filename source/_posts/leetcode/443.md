---
title: 443. 压缩字符串
categories:
- leetcode算法题
tags:
- Swift
- 双指针
- 字符串
---

题目链接：https://leetcode-cn.com/problems/string-compression/

执行用时：28 ms, 在所有 Swift 提交中击败了94.44% 的用户
内存消耗：13.7 MB, 在所有 Swift 提交中击败了100.00% 的用户

### 解题思路
开辟一个字符串来保存字符和个数，最后再转换为字符数组。 28ms

1. 慢指针指向要压缩的字符
2. 移动快指针，遇到相同字符即计数，若快指针已经走到末尾，将该字符和计数一起转为字符串存入str
3. 若遇到不相同字符，判断当前字符个数
- 如果是一个，说明下一个是新字符，当前字符转为字符串存入str
- 否则将该字符和计数一起转为字符串后存入str
- 使慢指针指向快指针位置，此时慢指针所指字符为下一轮匹配字符
- 重置计数
4. 快指针向后移动

### 代码

```swift
class Solution {
    func compress(_ chars: inout [Character]) -> Int {
        var ch: Character, count = 1, slow = 0,fast = 1
        var n = chars.count
        var str: String = ""
        while slow != n {
            ch = chars[slow]
            if fast < n && ch == chars[fast]{
                count += 1
                if fast + 1 == n  {
                    str += String(ch) + String(count)
                    break
                }
            }else {
                if count != 1{
                    str += String(ch) + String(count)
                }else{
                    str += String(ch)
                }
                slow = fast
                count = 1
            }
            fast += 1
        }
        chars = Array(str)
        return chars.count
    }
}

```

原地赋值, 20ms

``` swift
class Solution {
    func compress(_ chars: inout [Character]) -> Int {
        var slow = 0, nextCh = 0
        let n = chars.count
        for read in 0 ..< n {
            //判断是否走到末尾 或者 前后字符不相同时计算个数
            if read + 1 == n || chars[read] != chars[read+1] {
                //将比较中的字符赋给慢指针所处字符
                chars[slow] = chars[nextCh]
                //慢指针向后移动，该位置开始存放计数值
                slow += 1
                // 字符只有一个时无需计数, read 和 nextCh重合
                if read > nextCh {
                    //计算相同字符长度，并赋值
                    for ch in Array(String(read - nextCh + 1)) {
                        chars[slow] = ch
                        slow += 1
                    }
                }
                //指向下一个需要比较的字符
                nextCh = read + 1
            }
        }
        return slow
    }
}
```